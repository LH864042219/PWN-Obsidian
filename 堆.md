堆（heap），pwn的一道分水岭，各种教程都会叽里呱啦说一堆东西和名词，一时半会还是看不懂，还是边做题边学。
# 基础概念
但话说回来，一些基础概念还是要知道的。
## 堆概述
首先，堆（Heap）是虚拟地址空间的一块连续的线性区域，提供动态分配的内存，允许程序申请大小未知的内存，它在用户与操作系统之间，作为动态内存管理的中间人。同时堆响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，管理用户所释放的内存，并在合适的时候还给操作系统。
简单来说，堆主要是指用户动态申请的内存（如调用malloc、alloc、alloca、new等函数）。
目前有以下几种内存分配器：
- Dlmalloc-General purpose allocator
- **ptmalloc2-glibc** (重点)
- Jemalloc-Firefox    
- Tcmalloc-chrome   
- ...
CTF比赛中有关堆的PWN题大多是基于Linux的ptmalloc2-glibc堆块管理机制的。因此目前学的都是该管理器。
![[Pasted image 20250227153925.png]]
堆管理器并非由操作系统实现，而是由libc.so.6链接库实现。封装了一些系统调用，为用户提供方便的动态内存分配接口的同时，力求高效地管理由系统调用申请来的内存，申请内存的系统调用有brk和mmap两种。
1. brk是将数据段(.data)的最高地址指针_edata往高地址推。（_edata指向数据段的最高地址）
2. mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。
这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。malloc小于128k的内存时，glibc使用brk分配内存；大于128k时，使用mmap分配内存，在堆和栈之间找一块空闲内存分配。第一次执行malloc可能出现的系统调用如下。
![[Pasted image 20250227154039.png]]
## Arena
（翻译了一下这个单词是竞技场的意思，感觉怪怪的，还是叫他的原文吧）
一个线程申请的1个或多个堆包含很多的信息：二进制位信息，多个malloc_chunk信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的，也可以理解为堆管理器所持有的内存池。

操作系统-->堆管理器-->用户
物理内存--> arena -> 可用内存

堆管理器与用户的内存交易发生于arena中，可以理解为堆管理器向操作系统批发来的有冗余的内存库存。
一个线程只有一个arnea，并且这些线程的arnea都是独立的不是相同的
主线程的arnea称为“main_arena”。子线程的arnea称为“thread_arena”。
主线程无论一开始malloc多少空间，只要size<128KB，kernel都会给132KB的heap segment(rw)。这部分称为main arena。 main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。
![[Pasted image 20250227154705.png]]
![[Pasted image 20250227154720.png]]
后续的申请的内存会一直从这个arena中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间。
即使将所有main arena所分配出去的内存块free完，也不会立即还给kernel，而是交由glibc来管理。当后面程序再次申请内存时，在glibc中管理的内存充足的情况下，glibc就会根据堆分配的算法来给程序分配相应的内存。

总结一下就是说，Arena是管理一个线程内所有堆块的，不同的线程有不同的Arena独立管理